---
title: "nested choice model"
output: html_document
date: "2024-01-29"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, here, lubridate, apollo, fastDummies)
```

This script reads in choice data from angler diaries, fits nested logit model predicting 
fishing participation (yes, no) and type of waterbody (river, great lake, inland lake)

```{r}
choiceData<-read_csv(here::here("data","choice.data.participation.waterbody.type.csv"))
choiceData<-choiceData[,-1]

greatLake<-choiceData%>%
  filter(WaterFished%in%c("Lake Michigan","Lake Superior"))%>%
  group_by(WaterFished)%>%
  summarize(n=n())
# hm, not that many.

holidays<-mdy(c("05/31/2021","09/06/2021","11/25/2021","12/31/2021",
                "01/17/2022"))

coastal<-read_csv(here::here("data","coastalCounties.csv"))

river<-coastal%>%
  filter(grepl("River", waterbody))

greatLake<-coastal%>%
  filter(grepl("Lake", waterbody))

lakeMichigan<-coastal%>%
  filter(waterbody=="Lake Michigan")

lakeSuperior<-coastal%>%
  filter(waterbody=="Lake Superior")

choiceData.cov<-choiceData%>%
  mutate(Date=mdy(Date),
         month=as.character(month(Date, label=T)),
         weekday=wday(Date, label=T),
         weekendHoliday=ifelse(weekday%in%c("Sun","Sat") | Date%in%holidays, 1, 0),
         coastal_greatLake=ifelse(PrimaryCounty%in%greatLake$county, 1, 0),
         coastal_river=ifelse(PrimaryCounty%in%river$county, 1, 0),
         coastal_lakeMichigan=ifelse(PrimaryCounty%in%lakeMichigan$county, 1, 0),
         coastal_lakeSuperior=ifelse(PrimaryCounty%in%lakeSuperior$county, 1, 0),
         age=2022-YearOfBirth)%>%
  select(SurveyID, age, PrimaryCounty, Date, fishedEver, FishedYN, WaterFished, County, Hours:waterbodyType,
         coastal_greatLake, coastal_river, coastal_lakeMichigan, coastal_lakeSuperior, month, weekday, weekendHoliday)%>%
  mutate(age.sc=scale(age, center=T, scale=T),
         choice.partic=ifelse(FishedYN==0, "noFish", "fish"),
         choice.waterbody=ifelse(FishedYN==0, "noFish",
                       ifelse(waterbodyType=="river", "river",
                              ifelse(waterbodyType=="greatLake", "greatLake",
                                     ifelse(waterbodyType=="inlandLake", "inlandLake","error")))),
         choice=ifelse(fishedEver==0, "neverFished",
                       ifelse(FishedYN==0, "notToday",
                              ifelse(waterbodyType=="river","river",
                                     ifelse(waterbodyType=="greatLake", "greatLake",
                                            ifelse(waterbodyType=="inlandLake", "inlandLake", "error"))))),
         choice.specificLake=ifelse(FishedYN==0, "noFish", 
                                    ifelse(waterbodyType=="river","river",
                                           ifelse(waterbodyType=="inlandLake", "inlandLake",
                                                  ifelse(WaterFished=="Lake Michigan", "lakeMichigan",
                                                         ifelse(WaterFished=="Lake Superior", "lakeSuperior", "error"))))),
         age_weekend=age.sc*weekendHoliday)%>%
  mutate(shoulder=ifelse(month%in%c("Oct","Nov","Mar","Apr"), 1, 0),
         peakSummer=ifelse(month%in%c("May","Jun","Jul"), 1, 0))


choiceData.dum<-dummy_cols(choiceData.cov, select_columns="month",
                           remove_first_dummy=F,
                           remove_selected_columns=T)

```

Troubleshooting weird negative relationship between living in a coastal county and fishing in the Great Lakes. Dividing Superior from Michigan may help, but let's visualize:

```{r}
summary.nonspecific<-choiceData.cov%>%
  group_by(choice.specificLake, coastal_greatLake)%>%
  summarize(n=n())
summary.nonspecific
```
in aggregate, it does look like coastal county anglers are more likely to fish their great lake, especially Superior. (I had it backwards, huh)
```{r}

choiceData.cov.f<-choiceData%>%
  mutate(Date=mdy(Date),
         month=as.character(month(Date, label=T)),
         weekday=wday(Date, label=T),
         weekendHoliday=ifelse(weekday%in%c("Sun","Sat") | Date%in%holidays, 1, 0),
         coastal_greatLake=ifelse(PrimaryCounty%in%greatLake$county, 1, 0),
         coastal_river=ifelse(PrimaryCounty%in%river$county, 1, 0),
         age=2022-YearOfBirth)%>%
  select(SurveyID, age, PrimaryCounty, Date, fishedEver, FishedYN, WaterFished, County, Hours:waterbodyType,
         coastal_greatLake, coastal_river, month, weekday, weekendHoliday)%>%
  mutate(age.sc=scale(age, center=T, scale=T),
         choice.partic=ifelse(FishedYN==0, "noFish", "fish"),
         choice.waterbody=ifelse(FishedYN==0, "noFish",
                       ifelse(waterbodyType=="river", "river",
                              ifelse(waterbodyType=="greatLake", "greatLake",
                                     ifelse(waterbodyType=="inlandLake", "inlandLake","error")))),
         age_weekend=age.sc*weekendHoliday)%>%
  filter(fishedEver==1)%>%
  mutate(shoulder=ifelse(month%in%c("Oct","Nov","Mar","Apr"), 1, 0),
         peakSummer=ifelse(month%in%c("May","Jun","Jul"), 1, 0))



choiceData.dum.f<-dummy_cols(choiceData.cov.f, select_columns="month",
                           remove_first_dummy=F,
                           remove_selected_columns=T)
```
Jumping straight to  nested logit didn't work, shocking no one but myself. 

Start simpler with logit: fishing vs not

```{r}

### Initialise code
apollo_initialise()

### Set core controls
apollo_control = list(
  modelName       = "logit_participation",
  modelDescr      = "Simple logit model--participation",
  indivID         = "SurveyID", 
  outputDirectory = "output_logit_participation"
)

# ################################################################# #
#### LOAD DATA AND APPLY ANY TRANSFORMATIONS                     ####
# ################################################################# #

### Loading data from package
### if data is to be loaded from a file (e.g. called data.csv), 
### the code would be: database = read.csv("data.csv",header=TRUE)
database = choiceData.dum
### for data dictionary, use ?apollo_modeChoiceData


# ################################################################# #
#### DEFINE MODEL PARAMETERS                                     ####
# ################################################################# #

### Vector of parameters, including any that are kept fixed in estimation
apollo_beta=c(asc_noFish=1,
              asc_fish=0,
               b_weekend_holiday=0,
              # b_shoulder=0,
              # b_peakSummer=0,
               b_age=0,
               b_age_weekend = 0,
                b_month_Feb=0,
                b_month_Mar=0,
                b_month_Apr=0,
                b_month_May=0,
                b_month_Jun=0,
                b_month_Jul=0,
                b_month_Aug=0,
                b_month_Sep=0,
                b_month_Oct=0,
                # no November data
                b_month_Dec=0
              )

### Vector with names (in quotes) of parameters to be kept fixed at their starting value in apollo_beta, use apollo_beta_fixed = c() if none
apollo_fixed = c("asc_noFish")

# ################################################################# #
#### GROUP AND VALIDATE INPUTS                                   ####
# ################################################################# #

apollo_inputs = apollo_validateInputs()

# ################################################################# #
#### DEFINE MODEL AND LIKELIHOOD FUNCTION                        ####
# ################################################################# #

apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){

  ### Attach inputs and detach after function exit
  apollo_attach(apollo_beta, apollo_inputs)
  on.exit(apollo_detach(apollo_beta, apollo_inputs))

  ### Create list of probabilities P
  P = list()
  
  ### List of utilities: these must use the same names as in mnl_settings, order is irrelevant
  V = list()
  V[["noFish"]]  = asc_noFish
  V[["fish"]]  = asc_fish + b_weekend_holiday * weekendHoliday + b_month_Feb * month_Feb + 
    b_month_Mar * month_Mar + b_month_Apr * month_Apr + b_month_May * month_May +
    b_month_Jun * month_Jun + b_month_Jul * month_Jul + b_month_Aug * month_Aug +
    b_month_Sep * month_Sep + b_month_Oct * month_Oct + b_month_Dec * month_Dec +
    b_age * age.sc + b_age_weekend * age_weekend


  
  ### Define settings for MNL model component
  mnl_settings = list(
    alternatives  = c(noFish="noFish", fish="fish"), 
    choiceVar     = choice.partic,
    utilities     = V
  )
  
  ### Compute probabilities using MNL model
  P[["model"]] = apollo_mnl(mnl_settings, functionality)

  ### Take product across observation for same individual
  P = apollo_panelProd(P, apollo_inputs, functionality)

  ### Prepare and return outputs of function
  P = apollo_prepareProb(P, apollo_inputs, functionality)
  return(P)
}

# ################################################################# #
#### MODEL ESTIMATION                                            ####
# ################################################################# #

model = apollo_estimate(apollo_beta, apollo_fixed, apollo_probabilities, apollo_inputs)

# ################################################################# #
#### MODEL OUTPUTS                                               ####
# ################################################################# #

# ----------------------------------------------------------------- #
#---- FORMATTED OUTPUT (TO SCREEN)                               ----
# ----------------------------------------------------------------- #

apollo_modelOutput(model)

# ----------------------------------------------------------------- #
#---- FORMATTED OUTPUT (TO FILE, using model name)               ----
# ----------------------------------------------------------------- #

apollo_saveOutput(model)


```

Instead of nested logit (tried below--problems with nesting parameter), trying normal MNL with covariates. Got weird result for effects of living in a coastal county--trying again with specific coasts
If that works out, try MMNL

```{r}
# ################################################################# #
#### LOAD LIBRARY AND DEFINE CORE SETTINGS                       ####
# ################################################################# #


### Initialise code
apollo_initialise()

### Set core controls
apollo_control = list(
  modelName       = "MNL_participate_waterbodyType",
  modelDescr      = "MNL participation and waterbody type",
  indivID         = "SurveyID", 
  outputDirectory = "output_mnl_fish_waterbody"
)

# ################################################################# #
#### LOAD DATA AND APPLY ANY TRANSFORMATIONS                     ####
# ################################################################# #

### Loading data from package
### if data is to be loaded from a file (e.g. called data.csv), 
### the code would be: database = read.csv("data.csv",header=TRUE)
database = choiceData.dum
### for data dictionary, use ?apollo_modeChoiceData


# ################################################################# #
#### DEFINE MODEL PARAMETERS                                     ####
# ################################################################# #

### Vector of parameters, including any that are kept fixed in estimation. no observations in november, left out on purpose. 
apollo_beta=c( asc_noFish=0,
               asc_fish=0,
              b_weekend_holiday=0,
              b_age=0,
              b_weekend_age=0,
                b_month_Feb=0,
                b_month_Mar=0,
                b_month_Apr=0,
                b_month_May=0,
                b_month_Jun=0,
                b_month_Jul=0,
                b_month_Aug=0,
                b_month_Sep=0,
                b_month_Oct=0,
                # no November data
                b_month_Dec=0,
              b_coastal_lakeMichigan=0,
              b_coastal_lakeSuperior=0,
              b_coastal_river=0

              )

### Vector with names (in quotes) of parameters to be kept fixed at their starting value in apollo_beta, use apollo_beta_fixed = c() if none
apollo_fixed = c("asc_noFish")

# ################################################################# #
#### GROUP AND VALIDATE INPUTS                                   ####
# ################################################################# #

apollo_inputs = apollo_validateInputs()

# ################################################################# #
#### DEFINE MODEL AND LIKELIHOOD FUNCTION                        ####
# ################################################################# #

apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){

  ### Attach inputs and detach after function exit
  apollo_attach(apollo_beta, apollo_inputs)
  on.exit(apollo_detach(apollo_beta, apollo_inputs))

  ### Create list of probabilities P
  P = list()
  
  ### create alternative specific constants
  
  asc_fish_value = asc_fish + b_weekend_holiday * weekendHoliday + b_month_Feb * month_Feb + 
    b_month_Mar * month_Mar + b_month_Apr * month_Apr + b_month_May * month_May +
    b_month_Jun * month_Jun + b_month_Jul * month_Jul + b_month_Aug * month_Aug +
    b_month_Sep * month_Sep + b_month_Oct * month_Oct + b_month_Dec * month_Dec +
    b_age * age.sc + b_weekend_age * age_weekend
  
  ### List of utilities: these must use the same names as in mnl_settings, order is irrelevant

  V = list()
  V[["noFish"]] = asc_noFish 
  V[["river"]] = asc_fish_value + b_coastal_river * coastal_river
  V[["lakeMichigan"]] =  asc_fish_value + b_coastal_lakeMichigan * coastal_lakeMichigan
  V[["lakeSuperior"]] = asc_fish_value + b_coastal_lakeSuperior * coastal_lakeSuperior
  V[["inlandLake"]] = asc_fish_value

 ### Define settings for MNL model component
  mnl_settings = list(
    alternatives = c(noFish="noFish", river="river", lakeMichigan="lakeMichigan", lakeSuperior="lakeSuperior", inlandLake="inlandLake"),
    choiceVar    = choice.specificLake,
    utilities    = V
  )
  
  ### Compute probabilities using MNL model
  P[["model"]] = apollo_mnl(mnl_settings, functionality)
  
  ### Take product across observation for same individual
  P = apollo_panelProd(P, apollo_inputs, functionality)
  
  ### Prepare and return outputs of function
  P = apollo_prepareProb(P, apollo_inputs, functionality)
  return(P)
}

# ################################################################# #
#### MODEL ESTIMATION                                            ####
# ################################################################# #

model = apollo_estimate(apollo_beta, apollo_fixed, apollo_probabilities, apollo_inputs)

# ################################################################# #
#### MODEL OUTPUTS                                               ####
# ################################################################# #

# ----------------------------------------------------------------- #
#---- FORMATTED OUTPUT (TO SCREEN)                               ----
# ----------------------------------------------------------------- #

apollo_modelOutput(model)

# ----------------------------------------------------------------- #
#---- FORMATTED OUTPUT (TO FILE, using model name)               ----
# ----------------------------------------------------------------- #

apollo_saveOutput(model)

# ################################################################# #
##### POST-PROCESSING                                            ####
# ################################################################# #

### Print outputs of additional diagnostics to new output file (remember to close file writing when complete)
apollo_sink()
```

beta value of coastal_greatLake doesn't make sense to me--it's negative? 
Actually, maybe it makes more sense to break up lake superior and michigan. They're
very different form each other, and anglers in northern counties have lots of inland lakes
to choose from. 

Oh interesting! Breaking up Lake Superior and Michigan, coastal county residents of Lake Michigan were less likely, all else being equal, to choose fishing in Lake Michigan. 

```{r}
choiceData.dum%>%
  group_by(coastal_lakeMichigan)%>%
  mutate(total=n())%>%
  ungroup()%>%
  group_by(coastal_lakeMichigan, choice.specificLake)%>%
  summarize(n=n(),
            total=unique(total),
            prop=n/total)
```


```{r}
coastalGreatLake<-choiceData.dum%>%
  filter(coastal_greatLake==1)

unique(coastalGreatLake$PrimaryCounty)


```


```{r}
summary<-choiceData.dum%>%
  group_by(choice.waterbody, coastal_greatLake)%>%
  summarize(n=n())

summary
```


Nested logit still has the problem of a negative lambda value, which isn't allowed.
Yes, I'm going with this not being appropriate. Deleting nested model


suggestion to instead try mixed logit for panel data https://www.statalist.org/forums/forum/general-stata-discussion/general/1569500-nested-logit-with-panel-data 
    